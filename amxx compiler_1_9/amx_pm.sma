/* Plugin generated by AMXX-Studio 

	AMX_PrivateMessage (AMX_PM)
		By: Brandon "liverwiz"
		Last Edit: 08/09/2012
	
	No warrenties of any kind, especially for idiots that break stuff
 	Support available on the indicated AM thread
		
	Located on AlliedModers Forums:
		http://forums.alliedmods.net/showthread.php?t=188906
		
	DESCRIPTION: This mod allows for anyone to private message
	    anyone else in the server through chat or console, displaying
	    a colored message and sound to the reciever prefixed 
	    with [PM] <Sender's Name>:
	    Includes functionality to keep dead clients from talking 
	    to live clients, ability for clients to talk to or page admins, 
	    and admins to talk to anyone reguardless of PM enablement
	    PM Bans, toggle, and blocking is also a feature
	    
	Thanks to: Connor (as always), Bugsy, and <VeCo> for helping me with 
		assorted things. Especially bitsums and using bitarrays as toggles
	    
	CVARs:
		private_message 1 // <-1|0|1> Toggles amx_pm on or off -1 to turn off plugin 
									0 to turn off ghosting
									1 to allow dead users to talk to live users
		pm_sound "buttons/blip2.wav" // Sounds made at PM, empty to turn off
		
		
	Commands:
			.: CLIENTS :.			(say commands)
		!<username> [<message>]		Sends message to specified user
		amx_pm <username> [<message>]	Sends message to specified user- overrides your disablement
		!admin [<message>] 		Sends message to all admins
		/pm				amx_pm Menu
		/pm [on|off|block|help]		Shortcut to menu options
		pm_menu				amx_pm Menu console command
		/pageadmin			Pages all admins
		/block [<username>]		Blocks the specified user
		pm_block			Blocks user by nick in console
			.: ADMINS :.			(say_team commands)
		/admin <username> [<message>] 	Sends admin message to specified user
		admin_pm <username> [<message>]	Sends admin message to specified user from console
		/ban [<username>]		Bans specified user (not allowed to PM)
		pm_ban				Bans user from console
		
	
	TODO:
		/pm commands i.e. /pm (on | off | block | help)
		Display if a user is banned in help prompt	-done-
		Get fancy and super efficient 			-done-
		    Bitsum all toggle arrays (pmOn, banned, blockList[33])
		Make colors changeable. (develop simplified colorchat.ini)
		Change /admin <user> to /<user> - maybe
*/

#include <amxmodx>
#include <amxmisc>

#define PLUGIN "Private Message"
#define VERSION "0.25"
#define AUTHOR "Liverwiz"

	/* You can edit this to whatever admin flag you wish to consider an admin of this plugin
	 * Reference: http://www.amxmodx.org/funcwiki.php?go=module&id=1#const_admin */
#define ADMIN_FLAG 	ADMIN_KICK

#define INVALIDPLAYERMENU		// Toggle to display menu after invalid player for ban/block

new g_maxClients

new toggle_pcvar
	/* This caches get_pcvar_num(toggle_pcvar) for multiple uses
	It is updated at every say/say_team command (so we have almost real-
	time cvar updates) rather than constantly calling get_pcvar native */
new toggleCache

new pm_sound[32]

	/* These are the macros that allow for easy bitsum calculations 
	for any of the toggle arrays. Most of them accept the raw id 
	except for the 'has' macro, which to allow for multiple checking
	takes the id butSum (id<id>). This is probably never used within
	the script, but it allows for a more clear perspective and scaling
	ability to possibly use my code as an example. The comments display
	how to utilize the macro's syntax and what you would be doing within 
	a bool:array and how they are used.
	  The 'array' is your bitsum variable and the ID is your player ID	*/
#define id<%1>			(1 << (%1 & 31) )	// This creates the player's ID in bitsum
#define enableBit(%1,%2)	%1 |= %2		// enableBit(array, bitSumID)	// array[id] = true;
#define disableBit(%1,%2)	%1 &= ~%2		// disableBit(array, bitSumID)// array[id] = false
#define toggleBit(%1,%2)	%1 ^= %2		// switchBit(array, bitSumID)	// array[id] = !array[id]
#define has(%1,%2)		%1 & %2			// has(array, bitSumID)	// if(array[id]

new onBits
new bannedBits
new blockList[33]	// [PlayerID] [blocked bitSumIDs]


public plugin_precache()
{
	new sound_pcvar = register_cvar("pm_sound", "buttons/blip2.wav")
	get_pcvar_string(sound_pcvar, pm_sound, charsmax(pm_sound) )
	
	if(pm_sound[0]) 
		precache_sound(pm_sound)
}
public plugin_init() 
{
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	toggle_pcvar = register_cvar("private_message", "0")
	
	register_concmd("amx_pm", "cmdConPM", -1, "amx_pm- [user] [message]")
	register_concmd("pm_menu", "cmdPMmenu", -1, "-Opens the Private Message client menu")
	register_concmd("pm_block", "cmdBlock", -1, "pm_block- [user] -Blocks specified user")
	register_concmd("admin_pm", "cmdAdminPM", ADMIN_FLAG, "-Sends PM to user as admin, overriding any block or disable")
	register_concmd("pm_ban", "cmdAdminBan", ADMIN_FLAG, "pm_ban [user] -Bans the specified user")
	
	register_clcmd("say /pm", "cmdPMmenu", 0, "-Opens the Private Message client menu")
	register_clcmd("say_team /pm", "cmdPMmenu", 0, "-Opens the Private Message client menu")
	register_clcmd("say /pageadmin", "pageAdmin", 0, "-Pages all admins")
	
	/* These commands cannot be registered. They are handled within cmdPM and cmdPMa
	*	they are just to show what commands are available and how they are handled
	* register_clcmd("say /block", "cmdBlock", 0, "/block <nick>: block specified user")
	* register_clcmd("say !admin", "messageAdmin", 0, "!admin <message>: messages admins")
	* register_clcmd("say_team /admin", "cmdAdminPM", ADMIN_FLAG, "/admin <user> <message>: Sends an admin message to user")
	* register_clcmd("say_team /ban", "cmdAdminBan", ADMIN_FLAG, "/ban <user> <message>: Bans a user from using Private Message")
	*/
	
	register_clcmd("say", "cmdPM", 0, "-Client Private Message/Commands: !<nick> <message>")
	register_clcmd("say_team", "cmdPMa", ADMIN_FLAG, "-Admin Private Message/Commands: /admin <user> <message>: Sends admin message to user")
	
	register_dictionary("amx_pm.txt")
	
	g_maxClients = get_maxplayers()
	
	toggleCache = get_pcvar_num(toggle_pcvar)	// Start out with a good cache
	
	createMainMenu()
}
public client_connect(id)
{
	enableBit(onBits, id<id>)	// Turn PM on for new clients
	disableBit(bannedBits, id<id>)	// Unban client
	
	for(new i = 1; i <= g_maxClients; i++)
		disableBit(blockList[i], id<id>)
}


	/********************************
	*	CLIENT COMMANDS		*
	********************************/
public cmdPM(id)
{
	toggleCache = get_pcvar_num(toggle_pcvar)
	
	if(toggleCache == -1)
		return PLUGIN_CONTINUE
		
	new args[192]; read_args(args, charsmax(args) )
	remove_quotes(args)	// take the raw string
	
	switch(args[0])	
	{
		
	case '!':	// make sure it starts with a ! (signifies PM)
	{
		new target[32], message[156]
				// This seperates the name from the message
		strbreak(args, target, charsmax(target), message, charsmax(message) )
		
		if(equal(target, "!admin")  )	// Admin messages always go through
		{
			new players[32], num
			get_players(players, num, "ch")
	
			for(new msg[192], i = 0; i < num; i++)
			{	// I chose not to cache players[i] because it'll be faster 
				//	when, in most cases, the user is NOT an admin.
				if(access(players[i], ADMIN_FLAG) )
				{
					formatex(msg, charsmax(msg), "[TO ADMIN] %s", message)
					printMessage(players[i], id, msg)
				}
			}
		}
		else if( has(onBits, id<id>) && !(has(bannedBits, id<id> )) )	//pmOn[id] && !banned[id])
		{		// This will get the uesr index from the defined name
			new player = cmd_target(id, target[1], CMDTARGET_NO_BOTS)
			
			if(!player)
			{
				client_print(id, print_chat, "%L", id, "INVALID_PLAYER", target[1]) 
				//client_print(id, print_console, "%L", id, "INVALID_PLAYER", target) 
			}
			else
				printMessage(player, id, message)
		}
		else
		{
			client_print(id, print_chat, "%L", id, "PM_DISABLED")
			//client_print(id, print_console, "%L", id, "PM_DISABLED")
		}
	}
	case'/': //contain(args, "/block") != -1)	// Signifies Chat command- Change if no other commands made
	{
		new command[192], target[32]
		strbreak(args, command, charsmax(command), target, charsmax(target) )
		
		if(equal(command, "/block") )
		{
			new player = cmd_target(id, target, CMDTARGET_NO_BOTS)
			if(!player) 
			{
				client_print(id, print_chat, "%L", id, "INVALID_PLAYER", target[1]) 
				//client_print(id, print_console, "%L", id, "INVALID_PLAYER", target) 
				
			#if defined INVALIDPLAYERMENU	
				new playersMenu = menu_create("Block User", "mh_block")
				mhlp_getPlayerMenu(playersMenu)
				menu_display(id, playersMenu, 0)
			#endif
					// This is to fix bugs
				return PLUGIN_CONTINUE
			}
			else 
			{
				blockUser(id, player)
					// so we don't print who blocked who
				return PLUGIN_HANDLED
			}
		}
		if(equal(command, "/pm") )
			menuShortcuts(id, target)
		else		// If its not a valid command we send it back to core
			return PLUGIN_CONTINUE
	}
	default:	return PLUGIN_CONTINUE
		
	}	// END SWITCH STATEMENT
	
	return PLUGIN_HANDLED_MAIN
}
public cmdConPM(id, level, cid)	// amx_pm [user] [message]
{
	if(!cmd_access(id, level, cid, 3) || toggleCache == -1)
		return PLUGIN_HANDLED
	
		/* We need to parse and seperate the args
			This is because it will only read the first 
			word of the message otherwise */
	new args[300]; read_args(args, charsmax(args) )
	new target[32], message[192] // 192 is max length of chat message
		// Split the args
	strbreak(args, target, charsmax(target), message, charsmax(message) )
	
		// This will get the user index from the defined name
	new player = cmd_target(id, target, CMDTARGET_NO_BOTS)
	
	if(!player) 
	{
		//client_print(id, print_chat, "%L", id, "INVALID_PLAYER", target) 
		client_print(id, print_console, "%L", id, "INVALID_PLAYER", target)
	}
	else
		printMessage(player, id, message)
	
	return PLUGIN_HANDLED
}
public cmdBlock(id, level, cid)		// pm_block [user]
{
	if(!cmd_access(id, level, cid, 2) || toggleCache == -1)
		return PLUGIN_HANDLED
	
		// Get the user name
	new target[32]; read_argv(1, target, charsmax(target) )
	
		// This will get the user index from the defined name
	new player = cmd_target(id, target, CMDTARGET_NO_BOTS)
	
	
	if(!player) 
	{
		//client_print(id, print_chat, "%L", id, "INVALID_PLAYER", target) 
		client_print(id, print_console, "%L", id, "INVALID_PLAYER", target) 
	}
	else
		blockUser(id, player)
	
	return PLUGIN_HANDLED
}
public pageAdmin(id)		// /pageadmin
{
	if(toggleCache == -1)
		return PLUGIN_CONTINUE
		
	new players[32], num
	get_players(players, num, "ch")
		// Loop through all players; find & print to which ones have the admin flag
	for(new i = 0; i < num; i++)
	{	// I chose not to cache players[i] because it'll be faster 
		//	when, in most cases, the user is NOT an admin.
		if(access(players[i], ADMIN_FLAG) )
			printMessage(players[i], id, "[TO ADMIN]")
	}
	return PLUGIN_HANDLED
}


	/********************************
	*	ADMIN COMMANDS		*	(say_team)
	********************************/
public cmdPMa(id)	// Admin Chat commands
{
	toggleCache = get_pcvar_num(toggle_pcvar)
	
	if(toggleCache == -1)
		return PLUGIN_CONTINUE
		
	if(!access(id, ADMIN_FLAG) )  
		client_print(id, print_chat, "%L", id, "NOADMIN_MSG")

	new args[192]; read_args(args, charsmax(args) )
	remove_quotes(args)	// take the raw string
	
	switch(args[0])	
	{	// Still in switch in case i add another later
		
	case '/': 	// Signifies Chat command/admin message
	{
		new command[192], target[32]
		strbreak(args, command, charsmax(command), target, charsmax(target) )
		
		if(equal(command, "/admin") )
		{
				// For this we use "command" as the message. So we don't need another string
			strbreak(target, target, charsmax(target), command, charsmax(command) )
			
			new player = cmd_target(id, target, CMDTARGET_NO_BOTS)
			format(command, charsmax(command), "[FROM ADMIN] %s", command)
			
			if(!player)
			{
				client_print(id, print_chat, "%L", id, "INVALID_PLAYER", target)
				//client_print(id, print_console, "%L", id, "INVALID_PLAYER", target)
			}
			else
				printMessage(player, id, command)
		}
		else if(equal(command, "/ban") )
		{
			static player
			strbreak(target, target, charsmax(target), command, charsmax(command) )
			player = cmd_target(id, target, CMDTARGET_NO_BOTS | CMDTARGET_OBEY_IMMUNITY)
			
			if(!player) 
			{
				client_print(id, print_chat, "%L", LANG_PLAYER, "INVALID_PLAYER", target) 
				//client_print(id, print_console, "%L", LANG_PLAYER, "INVALID_PLAYER", target) 
				
			#if defined INVALIDPLAYERMENU
				new plrMenu = menu_create("Player to Ban", "mh_ban", ADMIN_FLAG)
				mhlp_getBanPlayerMenu(plrMenu)
				menu_display(id, plrMenu, 0)
			#endif
			}
			else
				banUser(id, player)
		}
		else
			return PLUGIN_CONTINUE
	}
	default:	return PLUGIN_CONTINUE
		
	}	// END SWITCH
	
	return PLUGIN_HANDLED_MAIN
}
public cmdAdminPM(id, level, cid)	// admin_pm [name] [message]
{
	if(!cmd_access(id, level, cid, 3) || toggleCache == -1)
		return PLUGIN_HANDLED
		
		/* We need to parse and seperate the args
		This is because it will only read the first 
		word of the message otherwise */
	new args[300]; read_args(args, charsmax(args) )
	new target[32], message[192]
		// Split the args
	strbreak(args, target, charsmax(target), message, charsmax(message) )
	
			// This will get the user index from the defined name
	new player = cmd_target(id, target, CMDTARGET_NO_BOTS)
	
	if(!player) 
	{
		//client_print(id, print_chat, "%L", id, "INVALID_PLAYER", target) 
		client_print(id, print_console, "%L", id, "INVALID_PLAYER", target) 
	}
	else
	{
		format(message, charsmax(message), "[FROM ADMIN] %s", message)
		printMessage(player, id, message)
	}
	
	return PLUGIN_HANDLED
}
public cmdAdminBan(id, level, cid)	// pm_ban [user]
{
	if(!cmd_access(id, level, cid, 2) || toggleCache == -1)
		return PLUGIN_HANDLED
	
		// Get the user name
	new target[32]; read_argv(1, target, charsmax(target) )
	
			// This will get the user index from the defined name
	new player = cmd_target(id, target, CMDTARGET_NO_BOTS)
	
	
	if(!player) 
	{
		//client_print(id, print_chat, "%L", id, "INVALID_PLAYER", target) 
		client_print(id, print_console, "%L", id, "INVALID_PLAYER", target) 
	}
	else
		banUser(id, player)
	
	return PLUGIN_HANDLED
}


	/********************************
	*	Menu Functions 		*
	*	I create the main menu into a global
	*	so its quicker on the PM menu call
	*	because its always the same
	********************************/
new g_mainMenu
createMainMenu()
{
	g_mainMenu = menu_create("Private Message Menu", "menuHandler")
	
	menu_additem(g_mainMenu, "Toggle Private Messages", "1", 0)
	menu_additem(g_mainMenu, "Block User", "2", 0)
	menu_additem(g_mainMenu, "Page Admin", "3", 0)
	menu_additem(g_mainMenu, "Help", "4", 0)
	menu_additem(g_mainMenu, "Ban User (admin)", "5", ADMIN_FLAG)
	
	menu_setprop(g_mainMenu, MPROP_EXIT, MEXIT_ALL)

	return PLUGIN_CONTINUE
}
public menuShortcuts(id, szMenuItem[])
{
	strtolower(szMenuItem)
	switch(szMenuItem[0])
	{
		case 'o':
		{
			if(szMenuItem[1] == 'n' && szMenuItem[2] == EOS)	//on
			{
				if(has(onBits, id<id>) )
				{
					client_print(id, print_chat, "%L", id, "PM_ENABLED")
					//client_print(id, print_console, "%L", id, "PM_ENABLED")
				}
				else
					toggle(id)
			}
			else if(szMenuItem[1] == 'f' && szMenuItem[2] == 'f' && szMenuItem[3] == EOS)	//off
			{
				if(has(onBits, id<id>) )
					toggle(id)
				else
				{
					client_print(id, print_chat, "%L", id, "PM_DISABLED")
					//client_print(id, print_console, "%L", id, "PM_DISABLED")
				}
			}
			else
				return 0
		}
		case 'b':
		{
			if(equal(szMenuItem, "block") )
			{
				new playersMenu = menu_create("Block User", "mh_block")
				mhlp_getPlayerMenu(playersMenu)
				menu_display(id, playersMenu, 0)
			}
			else
				return 0
		}
		case 'h':
		{
			if(equal(szMenuItem, "help") )
				displayHelp(id)
			else
				return 0
		}
		default: return 0
	}
	
	return 1
}
displayHelp(id)
{
	new motd[1124], len
	
	if( has(bannedBits, id<id>) )		//banned[id])
	{
		len = formatex(motd, charsmax(motd), "<br><br><br><font color=red><h2>You are currently BANNED from Private Messaging!</h2><br>")
		len+= formatex(motd[len], charsmax(motd) - len, "An admin has banned you from private messaging. Sorry this happened.<br>Try protesting with !admin <message> command.</font>")
		show_motd(id, motd, "Private Message Help -Banned-")
		
		return 1
	}
	
	len = formatex(motd, charsmax(motd), "<font color=red><h3>You have Private Messages")
	len+= formatex(motd[len], charsmax(motd) - len, " <i>%s</i></h3><br>", has(onBits, id<id>) ? "ENABLED" : "DISABLED")
	len+= formatex(motd[len], charsmax(motd) - len, "You have the following players blocked: <ul>")
	
	new players[32], num 
	get_players(players, num, "ch")
	
	for(new name[32],sid[32],player, i = 0; i < num; i++)
	{
		player = players[i]
		if(has(blockList[id], id<player>) )	//blockList[player][id])
		{
			get_user_name(player, name, charsmax(name) )
			get_user_authid(player, sid, charsmax(sid) )
			len+= formatex(motd[len], charsmax(motd) - len, "<li> %s (%s)", name, sid)
		}
	}
	
	len+= formatex(motd[len], charsmax(motd) - len, "</ul><br><br><h3>The following commands are at your disposal:</h3><ul>")
	len+= formatex(motd[len], charsmax(motd) - len, "<li> say /pm [on|off|block|help] -Private Message Menu<li> say /block &#60;nick&#62;  -Blocks the designated player<li> say /block -Block Player menu")
	len+= formatex(motd[len], charsmax(motd) - len, "<li> say /pageadmin  -Pages all connected admins<li> say !admin &#60;message&#62;  -Sends message to all connected admins.")
	len+= formatex(motd[len], charsmax(motd) - len, "<li> say !&#60;nick&#62; [&#60;message&#62;]  -Sends a message to the specified user. Message is not required; otherwise sends a page.")
	len+= formatex(motd[len], charsmax(motd) - len, "<li> amx_pm &#60;nick&#62; [&#60;message&#62;]  -Same as !&#60;nick&#62;, but in your console.")
	if(access(id, ADMIN_FLAG) )
	{
		len+= formatex(motd[len], charsmax(motd) - len, "<br><br><b><u>ADMIN COMMANDS (Use <tt>Team Chat</tt> for these)</u></b><li> say_team /admin &#60;nick&#62; -Admin message specified player")
		len+= formatex(motd[len], charsmax(motd) - len, "<li> say_team /ban &#60;nick&#62; -Ban specified player from PMing<li> say_team /ban -Ban Player menu")
	}
	len+= formatex(motd[len], charsmax(motd) - len, "<br><br><h5>%s plugin version %s written by Liverwiz", PLUGIN, VERSION)
	len+= formatex(motd[len], charsmax(motd) - len, "Contact Liver on <a href=^"http://forums.alliedmods.net/showthread.php?t=188906^">Allied Modders Forums</a> for support.</h5></font>")
	
	show_motd(id, motd, "Private Message Help")
	
	return 1
}
public cmdPMmenu(id)	// pm_menu or /pm 
{
	if(toggleCache == -1)
		return PLUGIN_CONTINUE

	menu_display(id, g_mainMenu, 0)
	
	return PLUGIN_HANDLED
}
public menuHandler(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		//menu_destroy(menu)
		return PLUGIN_HANDLED
	}
	
	new choice, acs, cb
	new data[3], name[32]
	menu_item_getinfo(menu, item, acs, data, charsmax(data), name, charsmax(name), cb)
	
	choice = str_to_num(data)
	
	switch(choice)
	{
		case 1:	toggle(id)
		case 2: 
		{
			new playersMenu = menu_create("Block User", "mh_block")
			mhlp_getPlayerMenu(playersMenu)
			menu_display(id, playersMenu, 0)
		}
		case 3:	pageAdmin(id)
		case 4:	displayHelp(id)
		case 5:
		{
			new playerMenu = menu_create("Player to Ban", "mh_ban", ADMIN_FLAG)
			mhlp_getBanPlayerMenu(playerMenu)
			menu_display(id, playerMenu, 0)
		}
	}
	
	//menu_destroy(menu)
	return PLUGIN_HANDLED
}    
public mh_block(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED
	}
	
	new choice, acs, cb
	new data[3], name[32]
	menu_item_getinfo(menu, item, acs, data, charsmax(data), name, charsmax(name), cb)
	
	choice = str_to_num(data)
	if(!!choice)	// if choice was 0 we skip this and exit
		blockUser(id, choice)
	
	menu_destroy(menu)
	return PLUGIN_HANDLED
}
public mh_ban(id, menu, item)
{
	if(item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED
	}
	
	new choice, acs, cb
	new data[3], name[32]
	menu_item_getinfo(menu, item, acs, data, charsmax(data), name, charsmax(name), cb)
	
	choice = str_to_num(data)
	if(!!choice)	// if choice was 0 we skip this and exit
		banUser(id, choice)
	
	menu_destroy(menu)
	return PLUGIN_HANDLED
}
/*   THIS FUNCTION AUTOMATICALLY SETS THE EXIT (creates a useable menu) 
       p_menu is a pointer to the menu that we're going to add the players list to 
       source[] is the source menu to keep track of what's going on internally 
       itemAccess is the "access" paramater for menu_additem 
       getPlayersFlags[] is a string of flags for the get_players command  
       RETURNS: number of players in the list */ 
mhlp_getPlayerMenu(&p_menu, itemAccess=0, getPlayersFlags[]="ch") 
{ 
    new players[32], plyrCnt 
    new sz_name[32], sz_info[8] 
    get_players(players, plyrCnt, getPlayersFlags) 
     
    for(new player, i = 0; i < plyrCnt; i++) 
    { 
        player = players[i] 
        get_user_name(player, sz_name, charsmax(sz_name) ) 
        formatex(sz_info, charsmax(sz_info), "%d", player) 
        menu_additem(p_menu, sz_name, sz_info, itemAccess) 
    } 
     
    menu_setprop(p_menu, MPROP_EXIT, MEXIT_ALL) 
    return plyrCnt 
}
mhlp_getBanPlayerMenu(&p_menu)
{ 
    new players[32], plyrCnt, adminCnt
    new sz_name[32], sz_info[8] 
    get_players(players, plyrCnt, "ch") 
     
    for(new player, i = 0; i < plyrCnt; i++) 
    { 
        player = players[i] 
        if(!access(player, ADMIN_IMMUNITY))
        {
            get_user_name(player, sz_name, charsmax(sz_name) ) 
            formatex(sz_info, charsmax(sz_info), "%d", player) 
            menu_additem(p_menu, sz_name, sz_info, ADMIN_FLAG) 
        }
        else 
            adminCnt++		// This will allow the function to return a proper number of added clients
    } 
     
    if(adminCnt == plyrCnt)
	menu_additem(p_menu, "All users have immunity.", "0", ADMIN_FLAG)
	
    menu_setprop(p_menu, MPROP_EXIT, MEXIT_ALL) 
    return plyrCnt - adminCnt
}


	/********************************
	*	FUNCTIONY FUNCTIONS	*
	********************************/
public bool:toggle(id)
{
	//new bool:pmo = pmOn[id] = !pmOn[id]
	new bool:pmo = !!(toggleBit(onBits, id<id>) )	//(onBits switchBit(id) )
	
	client_print(id, print_chat, "%L", id, (pmo) ? "PM_ENABLED" : "PM_DISABLED")
	
	return pmo
}
public bool:blockUser(id, victim)
{
	new bool:bl = !!(toggleBit(blockList[id], id<victim>) )	//blockList[victim][id] = !blockList[victim][id]
	new name[32]; get_user_name(victim, name, charsmax(name) )
	
	client_print(id, print_chat, "%L", id, (bl) ? "USER_BLOCKED" : "USER_UNBLOCKED", name)
	return bl
}
public bool:banUser(admin, victim)
{
	//new bool:bl = banned[victim] = !banned[victim]		// set/lift the ban & cache as to not re-index
	new bool:bl = !!(toggleBit(bannedBits, id<victim>) )
	
	new adminName[32], victimName[32]
	get_user_name(admin, adminName, charsmax(adminName) )
	get_user_name(victim, victimName, charsmax(victimName) )
	
	show_activity(admin, adminName, "%L", LANG_PLAYER, (bl) ? "BAN_SET" : "BAN_UNSET",victimName)
		
	return bl
}

	// RETURNS: 0|1 based on weather it was sent or not
stock printMessage(reciever, sender, const message[])
{
	if(contain(message, "ADMIN]") == -1)	// All admin messages go through
	{
			// Check if the user is allowed to PM this person
		if(toggleCache == 0 && !is_user_alive(sender) && is_user_alive(reciever) )	
		{
			client_print(sender, print_chat, "%L", sender, "BAD_TARGET")
			client_print(sender, print_console, "%L", sender, "BAD_TARGET")
			return 0
		}
			// Check if the user is allowed to PM at all
		else if(has(blockList[reciever], id<sender>) || !(has(onBits, id<reciever>)) )	//blockList[reciever][sender] || !pmOn[reciever])
		{
			client_print(sender, print_chat, "%L", sender, "BLOCKED_MSG")
			client_print(sender, print_console, "%L", sender, "BLOCKED_MSG")
			return 0
		}
	}	// We don't want admins reading messages if they turned them off
	else if(access(reciever, ADMIN_FLAG) && (has(blockList[reciever], id<sender>) || !(has(onBits, id<reciever>))) )	//!pmOn[reciever]) )
		return 0
	
		// Get ready to pack the output
	new output[192], name[32]
	get_user_name(sender, name, charsmax(name) )
	
		// Pack the message to an output
		// This doesn't work so well built into the above if-statement
	if(message[0] == EOS)	// If there is no message, we want to send a [page] message
		formatex(output, charsmax(output), "^x04[PM] %s^x01: [PAGE]", name)
	else
		formatex(output, charsmax(output), "^x04[PM] %s^x01: %s", name, message)
		
		
		// Set the SayText msgid  -using static makes it so we only have to do it once
	static saytext = 0
	if(!saytext)	saytext = get_user_msgid("SayText")
	
		// Now we print the message
	message_begin(MSG_ONE, saytext, {0,0,0}, reciever)
	write_byte(reciever)
	write_string(output)
	message_end()
	
	if(sender != reciever)	// Keep a double message from printing to a client. 
	{
		message_begin(MSG_ONE, saytext, {0,0,0}, sender)
		write_byte(sender)
		write_string(output)
		message_end()
	}
		// Play the sound if there is one
	if(pm_sound[0])
		client_cmd(reciever, "speak ^"sound/%s^"", pm_sound)
	
	return 1
}
