/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <hamsandwich>
#include <xs> 
#include <engine> 
#include <WPMGPrintChatColor>
#include <next21_knife_core>
#include <next21_advanced>

#define PLUGIN "next21_duels"
#define VERSION "0.5"
#define AUTHOR "Psycrow"

#define IsEntityPlayer(%1) (1<=%1<=g_maxplayers)

new bool:duel_ready[33][33] // Есть ли дуэль между определенными игроками
new bool:duel_ready_one[33] // Есть ли дуэль у одного игрока (чтобы не создавать громоских циклов для простого условия)
new duel_frags[33][33] // Соотношения флагов у дуэлянтов
new idd[33] // Глобальная переменная для хранения id дуэлянта.

static sound_duel[] 				= "next21_duels/duel_challenge_accepted.wav"
static sound_win[]				= "next21_duels/win.wav"
static sound_lose[] 				= "next21_duels/lose.wav"
static duel_sprite 

new Float:g_fDelay[33]
new cvar_maxdistance 
new cvar_updatedelay

new g_maxplayers

public plugin_init()
{
	kc_register_custom_menu_item("Duel menu", "Check_Players")
	
	register_plugin(PLUGIN, VERSION, AUTHOR)
	
	register_clcmd( "say /duel", "Check_Players" )
	register_clcmd( "say_team /duel", "Check_Players" )
	register_clcmd( "say /unduel", "Unduel" )
	register_clcmd( "say_team /unduel", "Unduel" )
	RegisterHam(Ham_Killed,"player","Duel")
	register_message(get_user_msgid("TeamInfo"),"TeamInfoCallback")
	
	register_cvar("cv_duels_frags","3") // Кол-во убийств до победы
	register_cvar("cv_duels_reward","3000") // Награда за победу на дуэли. 0 - отключить вознагрождение
	register_cvar("cv_duels_losing","3000") // Взыскание за проигрыш на дуэли или выход из нее. 0 - отключить вознагрождение
	register_cvar("cv_duels_maxmoney","16000") // Если на сервере изменен параметр максимального кол-ва денег, указать его
	register_cvar("cv_duels_sounds","1") // Проигрыать ли звуки
	register_cvar("cv_duels_sprite","1") // Отображать ли спрайт
	
	cvar_maxdistance = register_cvar("cv_duel_distance",  "2000") 
	cvar_updatedelay = register_cvar("cv_duel_updatedelay", "0.1") 
	
	g_maxplayers = get_maxplayers()
}

public plugin_precache()
{		
	precache_sound(sound_duel)
	precache_sound(sound_win)
	precache_sound(sound_lose)
	
	duel_sprite  = precache_model("sprites/next21_duels/duel.spr") 
}

public client_connect(id)
{
	new s_Players[32], i_Num, player
	get_players(s_Players, i_Num)
	for (new i; i < i_Num; i++)
	{ 
		player = s_Players[i]
		duel_ready_one[id] = false
		duel_ready[id][player] = false
		duel_ready[player][id] = false
		duel_frags[id][player] = 0
		duel_frags[player][id] = 0
	}
}

public client_disconnect(id)
{
	if(!duel_ready_one[id])
	return
	
	new s_Players[32], i_Num, player
	get_players(s_Players, i_Num)
	for (new i; i < i_Num; i++)
	{ 
		player = s_Players[i]
		if(duel_ready[id][player])
		{
			new player_name[33]
			get_user_name(id, player_name, charsmax(player_name))
			PrintChatColor(player, PRINT_COLOR_RED, "!g[Duels] !tPlayer !g%s !thas left without saying a word. The duel is over.",player_name)
			duel_frags[player][id] = 0
			duel_ready[player][id] = false
			duel_ready_one[player] = false
			break
		}
	}
}

public Check_Players(id)
{
	if(duel_ready_one[id])
	{
		new d_Players[32], d_Num, d_player
		get_players(d_Players, d_Num)
		for (new i; i < d_Num; i++) 
		{ 
			d_player = d_Players[i]
			if(duel_ready[id][d_player])
			{
				new player_name[33]
				get_user_name(d_player, player_name, charsmax(player_name))
				PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tYou are playing against !g%s",player_name)
				PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tIf you want to surrender, type !g/unduel")
				return
			}
		}
	}
    
	new Players_Menu = menu_create("\rРљРѕРіРѕ РІС‹Р·РІР°С‚СЊ РЅР° РґСѓСЌР»СЊ?", "menu_handler") // Меню со списком игроков
	new s_Players[32], i_Num, i_Player // Массив для индексов игроков, общее число игроков, Игрок
	new s_Name[32], s_Player[10] // Имена для меню 

	get_players(s_Players, i_Num)
	for (new i; i < i_Num; i++) { 
		i_Player = s_Players[i]
		idd[i_Player] = id
	
		get_user_name(i_Player, s_Name, charsmax(s_Name))
		num_to_str(i_Player, s_Player, charsmax(s_Player))

		new team[32]
		get_user_team(i_Player,team,31)
		
		if(i_Player == id || get_user_team(i_Player) == get_user_team(id) || duel_ready_one[i_Player] || equal(team, "SPECTATOR"))
		format(s_Name,charsmax(s_Player),"\d%s", s_Name)
		
		menu_additem(Players_Menu, s_Name, s_Player, 0)
        
		}
	menu_setprop(Players_Menu, MPROP_EXITNAME, "\yExit")
	menu_setprop(Players_Menu, MPROP_NEXTNAME, "\yNext")
	menu_setprop(Players_Menu, MPROP_BACKNAME, "\yBack")
	menu_display(id, Players_Menu, 0)
}
 
public menu_handler(id, menu, item)
{
	if (item == MENU_EXIT)
	{
		menu_destroy(menu)
		return PLUGIN_HANDLED
	}
 
	new s_Data[6], s_Name[64], i_Access, i_Callback
	menu_item_getinfo(menu, item, i_Access, s_Data, charsmax(s_Data), s_Name, charsmax(s_Name), i_Callback)
    
	new i_Player = str_to_num(s_Data)
    
	if(id == i_Player)
	{
		PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tYou can't play against yourself!")
		Check_Players(id)
		return PLUGIN_HANDLED
	}
   
	if(get_user_team(id) == get_user_team(i_Player))
	{
		PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tYou can't play against a teammate!")
		Check_Players(id)
		return PLUGIN_HANDLED
	}
     
	if(duel_ready_one[i_Player])
	{
		PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tThe user is currently playing against another player.!")
		Check_Players(id)
		return PLUGIN_HANDLED
	}
	
	new team[32]
	get_user_team(i_Player,team,31)
	
	if(equal(team, "SPECTATOR"))
	{
		PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tРќРµР»СЊР·СЏ РІС‹Р·С‹РІР°С‚СЊ РЅР° РґСѓСЌР»СЊ Р·СЂРёС‚РµР»СЏ")
		Check_Players(id)
		return PLUGIN_HANDLED
	}
     

	new player_name[33], player_name_e[33]
	get_user_name(id, player_name, charsmax(player_name))
	get_user_name(i_Player, player_name_e, charsmax(player_name_e))
	
	PrintChatColor(i_Player, PRINT_COLOR_RED, "!g[Duels] !tPlayer !g%s wants to play against you",player_name)
	PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tWaiting for your answer !g%s!t...",player_name_e)
   
	new duel_Menu = menu_create("\rDo you want to play a duel", "menu_handler_duel")
    
	menu_additem(duel_Menu, "\wAccept", "1", 0)
	menu_additem(duel_Menu, "\wReject", "2", 0)
     
	menu_setprop(duel_Menu, MPROP_EXITNAME, "\yР’С‹С…РѕРґ")
	menu_setprop(duel_Menu, MPROP_NEXTNAME, "\yР’РїРµСЂРµРґ")
	menu_setprop(duel_Menu, MPROP_BACKNAME, "\yРќР°Р·Р°Рґ")
     
	menu_destroy(menu)
	menu_display(i_Player, duel_Menu, 0)
	return PLUGIN_HANDLED
} 
 
public menu_handler_duel(i_Player, menu, item)
{
	new id = idd[i_Player]
	if (item == MENU_EXIT)
	{
		new Player_name[33]
		get_user_name(i_Player, Player_name, 31) 
		PrintChatColor(i_Player, PRINT_COLOR_RED, "!g[Duels] !tYou have rejected a duel")
		PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tPlayer !g%s !thas just rejected playing a duel",Player_name)
		menu_destroy(menu)
		
		return PLUGIN_HANDLED
	}

	new d_Data[6], d_Name[64], d_Access, d_Callback

	menu_item_getinfo(menu, item, d_Access, d_Data, charsmax(d_Data), d_Name, charsmax(d_Name), d_Callback)

	new d_Key = str_to_num(d_Data)

	switch(d_Key)
	{
		case 1:
		{
			new Player_name_id[33], Player_name[33]
			get_user_name(id, Player_name_id, 31)
			get_user_name(i_Player, Player_name, 31)
			PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tPlayer !g%s !taccepted", Player_name)
			PrintChatColor(i_Player, PRINT_COLOR_RED, "!g[Duels] !tYou have accepted playing against !g%s",Player_name_id)
			PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tIf you want to win, you have to kill your enemy !g%d !ttimes",get_cvar_num("cv_duels_frags"))
			PrintChatColor(i_Player, PRINT_COLOR_RED, "!g[Duels] !tIf you want to win, you have to kill your enemy !g%d !ttimes",get_cvar_num("cv_duels_frags"))
			duel_ready[id][i_Player] = true
			duel_ready[i_Player][id] = true
			duel_ready_one[id] = true
			duel_ready_one[i_Player] = true
			menu_destroy(menu)
			if(get_cvar_num("cv_duels_sounds"))
			{
				client_cmd(i_Player, "spk %s", sound_duel)
				client_cmd(id, "spk %s", sound_duel)
			}
		}
		case 2:
		{
			new Player_name[33]
			get_user_name(i_Player, Player_name, 31) 
			PrintChatColor(i_Player, PRINT_COLOR_RED, "!g[Duels] !tYou have surrendered")
			PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tPlayer !g%s !thas surrendered",Player_name)
			menu_destroy(menu)
		}
	}
	return PLUGIN_HANDLED
}

public Duel(victim, attacker){		
	if(!IsEntityPlayer(attacker) || !IsEntityPlayer(victim))
		return HAM_IGNORED
		
	if(!duel_ready[victim][attacker] || !duel_ready[attacker][victim])
		return HAM_IGNORED
	
	new Player_name_a[33], Player_name_v[33]
	get_user_name(victim, Player_name_v, 31)
	get_user_name(attacker, Player_name_a, 31)
	
	duel_frags[attacker][victim] += 1
	
	if(duel_frags[attacker][victim] == get_cvar_num("cv_duels_frags"))
	{
		PrintChatColor(0, PRINT_COLOR_RED, "!g[Duels] !tThe duel between !g%s !tand !g%s !tis over. Winner !g%s, !tscore: !g%d!t-!g%d", Player_name_a, Player_name_v, Player_name_a, duel_frags[attacker][victim], duel_frags[victim][attacker])
		if(get_cvar_num("cv_duels_reward"))
		{
			new dl_maxmoney = 55000
			new dl_upmoney = get_cvar_num("cv_duels_reward")
			if((cs_get_user_money(attacker)+dl_upmoney) > dl_maxmoney)
			{
				PrintChatColor(attacker, PRINT_COLOR_RED, "!g[Duels] !tFor your win you get !g%d$",dl_maxmoney-cs_get_user_money(attacker))
				cs_set_user_money(attacker,dl_maxmoney)	
			}
			else
			{
				PrintChatColor(attacker, PRINT_COLOR_RED, "!g[Duels] !tFor your win you get !g%d$",dl_upmoney)
				cs_set_user_money(attacker,cs_get_user_money(attacker)+dl_upmoney)
			}
		}
		if(get_cvar_num("cv_duels_losing"))
		{
			new dl_downmoney = get_cvar_num("cv_duels_losing")
			if(cs_get_user_money(victim) < dl_downmoney)
			{
				PrintChatColor(victim, PRINT_COLOR_RED, "!g[Duels] !tYou lost !g%d$",cs_get_user_money(victim))
				cs_set_user_money(victim,0)
				
			}
			else
			{
				PrintChatColor(victim, PRINT_COLOR_RED, "!g[Duels] !tYou lost !g%d$",dl_downmoney)
				cs_set_user_money(victim,cs_get_user_money(victim)-dl_downmoney)
			}
		}
		if(get_cvar_num("cv_duels_sounds"))
		{
			client_cmd(attacker, "spk %s", sound_win)
			client_cmd(victim, "spk %s", sound_lose)
		}
		duel_frags[attacker][victim] = 0
		duel_frags[victim][attacker] = 0
		duel_ready[attacker][victim] = false
		duel_ready[victim][attacker] = false
		duel_ready_one[victim] = false
		duel_ready_one[attacker] = false
		return HAM_IGNORED
	}
		
	PrintChatColor(attacker, PRINT_COLOR_RED, "!g[Duels] !tGood Job, you need only !g%d !t more frags to win",get_cvar_num("cv_duels_frags") - duel_frags[attacker][victim])
	PrintChatColor(victim, PRINT_COLOR_RED, "!g[Duels] !tYour enemy needs!g%d !tfrags to win",get_cvar_num("cv_duels_frags") - duel_frags[attacker][victim])
	return HAM_IGNORED
}

public Unduel(id)
{
	if(!duel_ready_one[id])
	PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tYou haven't played in a duel")
	else
	{
		new s_Players[32], i_Num, player
		get_players(s_Players, i_Num)
		for (new i; i < i_Num; i++)
		{ 
			player = s_Players[i]
			if(duel_ready[id][player] || duel_ready[player][id])
			{
				new player_name[33]
				get_user_name(id, player_name, charsmax(player_name))
				PrintChatColor(player, PRINT_COLOR_RED, "!g[Duels] !tPlayer !g%s !t doesn't want to play.",player_name)
				PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tThe duel is over.")
				duel_frags[player][id] = 0
				duel_frags[id][player] = 0
				duel_ready[player][id] = false
				duel_ready[id][player] = false
				duel_ready_one[player] = false
				duel_ready_one[id] = false
				break
			}
		}
		if(get_cvar_num("cv_duels_losing"))
		{
			new dl_downmoney = get_cvar_num("cv_duels_losing")
			if(cs_get_user_money(id) < dl_downmoney)
			{
				PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tYou lose !g%d$",cs_get_user_money(id))
				cs_set_user_money(id,0)
				
			}
			else
			{
				PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tYou lose !g%d$",dl_downmoney)
				cs_set_user_money(id,cs_get_user_money(id)-dl_downmoney)
			}
		}
	}
	return PLUGIN_CONTINUE 
}

public TeamInfoCallback()
{
	new id = get_msg_arg_int(1)
	if(!duel_ready_one[id])
		return
	
	if(!IsEntityPlayer(id))
		return
			
	new s_Players[32], i_Num, player
	get_players(s_Players, i_Num)
	for (new i; i < i_Num; i++)
	{ 
		player = s_Players[i]
		new team[32]
		get_user_team(id,team,31)
		if(duel_ready[id][player] && (get_user_team(id) == get_user_team(player) || equal(team, "SPECTATOR")))
		{
			new player_name[33]
			get_user_name(id, player_name, charsmax(player_name))
			PrintChatColor(player, PRINT_COLOR_RED, "!g[Duels] !tPlayer !g%s !t has changed his team. The duel is over.",player_name)
			PrintChatColor(id, PRINT_COLOR_RED, "!g[Duels] !tYou have changed your team. The duel is over.")
			duel_frags[player][id] = 0
			duel_frags[id][player] = 0
			duel_ready[player][id] = false
			duel_ready[id][player] = false
			duel_ready_one[player] = false
			duel_ready_one[id] = false
			break
		}
	}
}

public client_PreThink(id) 
{
	if(!get_cvar_num("cv_duels_sprite"))
	return PLUGIN_CONTINUE 
	
	if(!is_user_alive(id))
	return PLUGIN_CONTINUE 
	
	if(!duel_ready_one[id])
	return PLUGIN_CONTINUE 

	if((g_fDelay[id] + get_pcvar_float(cvar_updatedelay)) > get_gametime())
	return PLUGIN_CONTINUE 

	g_fDelay[id] = get_gametime()
   
	new Float:fMyOrigin[3] 
	entity_get_vector(id, EV_VEC_origin, fMyOrigin)

	static Players[32], iNum
	get_players(Players, iNum, "a")
	for(new i; i < iNum; i++)
		if(id != Players[i])
		{ 
			new target = Players[i]
         
			if(!duel_ready[id][target])
			continue 
			
			if(ka_in_ninja(target))
			continue
			
			new Float:fTargetOrigin[3] 
			entity_get_vector(target, EV_VEC_origin, fTargetOrigin)
         
			if((get_distance_f(fMyOrigin, fTargetOrigin) > get_pcvar_num(cvar_maxdistance))
			|| !is_in_viewcone(id, fTargetOrigin))
			continue 
         
			new Float:fMiddle[3], Float:fHitPoint[3] 
			xs_vec_sub(fTargetOrigin, fMyOrigin, fMiddle) 
			trace_line(-1, fMyOrigin, fTargetOrigin, fHitPoint) 
         
			new Float:fWallOffset[3], Float:fDistanceToWall 
         
			fDistanceToWall = vector_distance(fMyOrigin, fHitPoint) - 10.0 
			normalize(fMiddle, fWallOffset, fDistanceToWall) 
     
			new Float:fSpriteOffset[3] 
			xs_vec_add(fWallOffset, fMyOrigin, fSpriteOffset) 
			new Float:fScale, Float:fDistanceToTarget = vector_distance(fMyOrigin, fTargetOrigin) 
			if(fDistanceToWall > 100.0) 
			fScale = 6.0 * (fDistanceToWall / fDistanceToTarget) 
			else 
			fScale = 1.5 
			te_sprite(id, fSpriteOffset, duel_sprite, floatround(fScale), 125) 
		} 
	return PLUGIN_CONTINUE 
} 

stock te_sprite(id, Float:origin[3], sprite, scale, brightness) 
{ 
	message_begin(MSG_ONE, SVC_TEMPENTITY, _, id) 
	write_byte(TE_SPRITE) 
	write_coord(floatround(origin[0])) 
	write_coord(floatround(origin[1])) 
	write_coord(floatround(origin[2]+40)) 
	write_short(sprite) 
	write_byte(scale)  
	write_byte(brightness) 
	message_end() 
} 

stock normalize(Float:fIn[3], Float:fOut[3], Float:fMul) 
{ 
	new Float:fLen = xs_vec_len(fIn) 
	xs_vec_copy(fIn, fOut) 

	fOut[0] /= fLen, fOut[1] /= fLen, fOut[2] /= fLen 
	fOut[0] *= fMul, fOut[1] *= fMul, fOut[2] *= fMul 
} 
